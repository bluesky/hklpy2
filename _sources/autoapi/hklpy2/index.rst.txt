hklpy2
======

.. py:module:: hklpy2

.. autoapi-nested-parse::

   Package-level initialization.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/hklpy2/backends/index
   /autoapi/hklpy2/blocks/index
   /autoapi/hklpy2/diffract/index
   /autoapi/hklpy2/incident/index
   /autoapi/hklpy2/misc/index
   /autoapi/hklpy2/ops/index
   /autoapi/hklpy2/user/index


Attributes
----------

.. autoapisummary::

   hklpy2.__settings_orgName__
   hklpy2.__package_name__
   hklpy2.__version__
   hklpy2.SI_LATTICE_PARAMETER
   hklpy2.A_KEV
   hklpy2.SOLVER_ENTRYPOINT_GROUP


Exceptions
----------

.. autoapisummary::

   hklpy2.SolverError


Classes
-------

.. autoapisummary::

   hklpy2.SolverBase
   hklpy2.Configuration
   hklpy2.DiffractometerBase
   hklpy2.ConfigurationRunWrapper


Functions
---------

.. autoapisummary::

   hklpy2._get_version
   hklpy2.creator
   hklpy2.diffractometer_class_factory
   hklpy2.get_solver
   hklpy2.solver_factory
   hklpy2.solvers


Package Contents
----------------

.. py:data:: __settings_orgName__
   :value: 'bluesky'


   GitHub organization/user name

.. py:data:: __package_name__
   :value: 'hklpy2'


   GitHub repository name and Python package name.

.. py:function:: _get_version(version_module=None)

   Return package version.

   Priority:

   1. From ``_version.py`` (generated by ``setuptools_scm``) if exists.
   2. Try ``importlib.metadata.version()``.
   3. Fall back to a safe default.


.. py:data:: __version__

   Package version string.

.. py:class:: SolverBase(geometry: str, *, mode: str = '', **kwargs)

   Bases: :py:obj:`abc.ABC`


   Base class for all |hklpy2| |solver| classes.

   PARAMETERS

   geometry : str
       Name of geometry.
   mode: str
       Name of operating mode.  (default: current mode)

   Example::

       import hklpy2

       class MySolver(hklpy2.SolverBase):
           ...

   .. note:: :class:`~SolverBase`, an `abstract base
       class <https://docs.python.org/3/library/abc.html#abc.ABC>`_,
       cannot not be used directly by |hklpy2| users.

   As the parent class for all custom :index:`Solver` classes,
   :class:`~SolverBase` defines the methods and attributes to be written
   that will connect |hklpy2| with the support library that defines
   specific diffractometer geometries and the computations for
   using them.  Subclasses should implement each of these methods
   as best fits the underlying support library.

   .. seealso:: :mod:`~hklpy2.backends.hkl_soleil` & :mod:`~hklpy2.backends.no_op`

   .. rubric:: Python Methods

   .. autosummary::

       ~addReflection
       ~calculate_UB
       ~extra_axis_names
       ~forward
       ~geometries
       ~inverse
       ~pseudo_axis_names
       ~real_axis_names
       ~refineLattice
       ~removeAllReflections

   .. rubric:: Python Properties

   .. autosummary::

       ~all_extra_axis_names
       ~extra_axis_names
       ~extras
       ~geometry
       ~lattice
       ~mode
       ~modes
       ~sample
       ~UB


   .. py:attribute:: name
      :value: 'base'


      Name of this Solver.


   .. py:attribute:: version

      Version of this Solver.


   .. py:attribute:: ANGLE_UNITS
      :value: 'degrees'


      Angle units used by this solver for unit cell and real axis rotations.

      Solver can override this **constant**.  Must be convertible to
      ``INTERNAL_ANGLE_UNITS``.


   .. py:attribute:: LENGTH_UNITS
      :value: 'angstrom'


      Length units used by this solver for unit cell and wavelength.

      Solver can override this **constant**.  Must be convertible to
      ``INTERNAL_LENGTH_UNITS``.


   .. py:attribute:: _gname


   .. py:property:: mode
      :type: str


      Diffractometer geometry operation mode for :meth:`forward()`.

      A mode defines which axes will be modified by the
      :meth:`forward` computation.


   .. py:attribute:: _all_extra_axis_names
      :value: None



   .. py:attribute:: _sample
      :value: None



   .. py:method:: __repr__() -> str


   .. py:property:: _metadata
      :type: dict


      Dictionary with this solver's summary metadata.


   .. py:method:: addReflection(reflection: Reflection) -> None
      :abstractmethod:


      Add coordinates of a diffraction condition (a reflection).



   .. py:property:: all_extra_axis_names
      :type: list[str]


      Unique, sorted list of extra axis names in all modes for chosen engine.


   .. py:method:: calculate_UB(r1: Reflection, r2: Reflection) -> list[list[float]]
      :abstractmethod:


      Calculate the UB (orientation) matrix with two reflections.

      The method of Busing & Levy, Acta Cryst 22 (1967) 457.



   .. py:property:: extra_axis_names
      :type: list[str]

      :abstractmethod:


      Ordered list of any extra axis names (such as x, y, z).


   .. py:property:: extras
      :type: dict


      Ordered dictionary of any extra parameters.


   .. py:method:: forward(pseudos: dict) -> list[dict[str, float]]
      :abstractmethod:


      Compute list of solutions(reals) from pseudos (hkl -> [angles]).



   .. py:method:: geometries() -> list[str]
      :classmethod:

      :abstractmethod:


      Ordered list of the geometry names.

      EXAMPLES::

          >>> from hklpy2 import get_solver
          >>> Solver = get_solver("no_op")
          >>> Solver.geometries()
          []
          >>> solver = Solver("TH TTH Q")
          >>> solver.geometries()
          []



   .. py:property:: geometry
      :type: str


      Name of selected diffractometer geometry.

      Cannot be changed once solver is created.  Instead, make a new solver
      for each geometry.


   .. py:method:: inverse(reals: dict) -> dict[str, float]
      :abstractmethod:


      Compute dict of pseudos from reals (angles -> hkl).



   .. py:property:: lattice
      :type: Lattice


      Crystal lattice parameters.  (Not used by this |solver|.)


   .. py:property:: modes
      :type: list[str]

      :abstractmethod:


      List of the geometry operating modes.


   .. py:property:: pseudo_axis_names
      :type: list[str]

      :abstractmethod:


      Ordered list of the pseudo axis names (such as h, k, l).


   .. py:property:: real_axis_names
      :type: list[str]

      :abstractmethod:


      Ordered list of the real axis names (such as th, tth).


   .. py:method:: refineLattice(reflections: list[Reflection]) -> Lattice
      :abstractmethod:


      Refine the lattice parameters from a list of reflections.



   .. py:method:: removeAllReflections() -> None
      :abstractmethod:


      Remove all reflections.



   .. py:property:: sample
      :type: object


      Crystalline sample.


   .. py:property:: _summary_dict

      Return a summary of the geometry (modes, axes)


   .. py:property:: summary
      :type: pyRestTable.Table


      Table of this geometry (modes, axes).

      .. seealso:: :ref:`geometries.summary_tables`,
          :func:`hklpy2.user.solver_summary()`


   .. py:property:: UB

      Orientation matrix (3x3).


.. py:class:: Configuration(diffractometer)

   Manage diffractometer configurations.

   .. autosummary::

       ~_asdict
       ~_fromdict
       ~_valid


   .. py:attribute:: diffractometer


   .. py:method:: _asdict() -> dict

      Return diffractometer's configuration as a dict.



   .. py:method:: _fromdict(config: dict, clear: bool = True, restore_constraints: bool = True)

      Restore diffractometer's configuration from a dict.



   .. py:method:: _valid(config)

      Validate incoming configuration for current diffractometer.



.. py:data:: SI_LATTICE_PARAMETER
   :value: 5.431020511


   2018 CODATA recommended lattice parameter of silicon, Angstrom.

   :see: https://physics.nist.gov/cgi-bin/cuu/Value?asil

.. py:class:: DiffractometerBase(prefix: str = '', *, solver: str = None, geometry: str = None, solver_kwargs: dict = {}, pseudos: list[str] = [], reals: list[str] = [], reals_units: Optional[str] = None, forward_solution_function: Optional[Callable] = None, **kwargs)

   Bases: :py:obj:`ophyd.PseudoPositioner`


   Base class for all diffractometers.

   PARAMETERS

   solver : str
       Name of |solver| library.
       (default: unspecified)
   geometry : str
       Name of |solver| geometry.
       (default: unspecified)
   solver_kwargs : Dict(str, Any)
       Any additional keyword arguments needed by |solver| library.
       (default: empty)
   pseudos : List[str]
       List of diffractometer axis names to be used
       as pseudo axes. (default: unspecified)
   reals : List[str]
       List of diffractometer axis names to be used as
       real axes. (default: unspecified)
   forward_solution_function : Callable
       Function to pick one solution from list of possibilities.
       Used by :meth:`~hklpy2.diffract.DiffractometerBase.forward`.
       (default: :func:`~hklpy2.misc.pick_first_solution`)
   reals_units : str
       The units for the real axes. (default: "degrees")

   .. rubric:: (ophyd) Components

   .. rubric:: Python Attributes

   .. autosummary::

       ~_forward_solution

   .. rubric:: Python Methods

   .. autosummary::

       ~add_reflection
       ~add_sample
       ~export
       ~forward
       ~full_position
       ~inverse
       ~move_dict
       ~move_forward_with_extras
       ~move_inverse_with_extras
       ~move_reals
       ~restore
       ~scan_extra
       ~wh

   .. rubric:: Python Properties

   .. autosummary::
       ~auxiliary_axis_names
       ~configuration
       ~pseudo_axis_names
       ~real_axis_names
       ~reals_units
       ~sample
       ~samples


   .. py:attribute:: beam

      Incident monochromatic beam.


   .. py:attribute:: _forward_solution
      :type:  Callable

      Pick a solution from solution(s) of  :meth:`~hklpy2.ops.Core.forward`.

      Choices include:

      * (default) :func:`hklpy2.misc.pick_first_solution`
      * :func:`hklpy2.misc.pick_closest_solution`
      * User-supplied function matching the same interface.

      .. seealso::
          :meth:`hklpy2.diffract.DiffractometerBase.forward`,
          :meth:`hklpy2.ops.Core.forward`


   .. py:attribute:: _backend
      :value: None



   .. py:property:: reals_units
      :type: str


      Engineering units for the reals (rotational) axes


   .. py:attribute:: core


   .. py:property:: digits
      :type: int


      Number of decimal digits used when rendering position tuples.

      This is a per-instance property. Reading returns the instance value if
      set, otherwise the class default. Setting updates the instance value
      and re-wraps the instance's PseudoPosition/RealPosition classes so the
      new digit count is used for their string representations.


   .. py:method:: add_reflection(pseudos, reals=None, wavelength: float = None, wavelength_units: str = None, name: str = None, replace: bool = False) -> hklpy2.blocks.reflection.Reflection

      Add a new reflection with this geometry to the selected sample.

      PARAMETERS

      pseudos various:
          Pseudo-space axes and values.
      reals various:
          Dictionary of real-space axes and values.
      wavelength float:
          Wavelength of incident radiation. If ``None``, diffractometer's
          current wavelength will be assigned.
      wavelength_units str:
          Optional units for the supplied ``wavelength`` (e.g. "angstrom").
          If ``None``, the diffractometer's current beam units are used.
      name str:
          Reference name for this reflection.
          If ``None``, a random name will be assigned.
      replace bool:
          If ``True``, replace existing reflection matching this name.
          (default: ``False``)



   .. py:method:: add_sample(name: str, a: float, b: float = None, c: float = None, alpha: float = 90.0, beta: float = None, gamma: float = None, digits: int = 4, replace: bool = False) -> hklpy2.blocks.sample.Sample

      Add a new sample.



   .. py:property:: configuration
      :type: dict


      Diffractometer configuration (orientation).


   .. py:method:: export(file, comment='')

      Export the diffractometer configuration to a YAML file.

      Example::

          import hklpy2

          e4cv = hklpy2.creator(name="e4cv")
          e4cv.export("e4cv-config.yml", comment="example")



   .. py:method:: restore(config, clear=True, restore_constraints=True, restore_wavelength=True)

      Restore diffractometer configuration.

      Example::

          import hklpy2

          e4cv = hklpy2.creator(name="e4cv")
          e4cv.restore("e4cv-config.yml")

      PARAMETERS

      config : dict, str, or pathlib object
          Dictionary with configuration, or name (str or pathlib object) of
          diffractometer configuration YAML file.
      clear : bool
          If ``True`` (default), remove any previous configuration of the
          diffractometer and reset it to default values before restoring the
          configuration.

          If ``False``, sample reflections will be append with all reflections
          included in the configuration data for that sample.  Existing
          reflections will not be changed.  The user may need to edit the
          list of reflections after ``restore(clear=False)``.
      restore_constraints : bool
          If ``True`` (default), restore any constraints provided.
      restore_wavelength : bool
          If ``True`` (default), restore wavelength.

      Note: Can't name this method "import", it's a reserved Python word.



   .. py:method:: forward(pseudos: dict, wavelength: float = None) -> tuple

      Compute real-space coordinates from pseudos (hkl -> angles).



   .. py:method:: full_position(digits=4) -> dict

      Return dict with positions of pseudos, reals, & extras.



   .. py:method:: inverse(reals: tuple, wavelength: float = None) -> tuple

      Compute pseudo-space coordinates from reals (angles -> hkl).



   .. py:method:: move_dict(axes: hklpy2.misc.AxesDict)

      (plan) Move diffractometer axes to positions in 'axes'.



   .. py:method:: move_forward_with_extras(pseudos: hklpy2.misc.AnyAxesType, extras: hklpy2.misc.AxesDict)

      (plan stub) Compute forward solution at fixed pseudos and extras.

      EXAMPLE::

          RE(
              move_forward_with_extras(
                  diffractometer,
                  pseudos=dict(h=2, k=1, l=0),
                  extras=dict(h2=2, k2=2, l2=0, psi=25),
              )
          )



   .. py:method:: move_inverse_with_extras(reals: hklpy2.misc.AnyAxesType, extras: hklpy2.misc.AxesDict)

      (plan stub) Compute inverse solution at fixed reals and extras.

      EXAMPLE::

          RE(
              move_inverse_with_extras(
                  diffractometer,
                  reals=dict(omega=10, chi=0, phi=0, phi=20),
                  extras=dict(h2=2, k2=2, l2=0, psi=25),
              )
          )



   .. py:method:: move_reals(reals: hklpy2.misc.AnyAxesType) -> None

      (not a plan) Move the real-space axes as specified in 'real_positions'.



   .. py:method:: scan_extra(detectors: collections.abc.Iterable[bluesky.protocols.Readable], *args: Union[bluesky.protocols.Movable, Any], num: Optional[int] = 2, pseudos: Optional[dict] = None, reals: Optional[dict] = None, extras: Optional[dict] = {}, fail_on_exception: Optional[bool] = False, md: Optional[dict] = None)

      Scan extra diffractometer parameter(s), such as 'psi'.

      * iterate extra positions as described:
          * set extras
          * solution = forward(pseudos)
          * move to solution
          * acquire (trigger) all controls
          * read and record all controls

      Parameters

      detectors: Iterable[Readable]
          List of readable objects.
      args: Any
          Specification of scan axes.

          The 'args' specification is a repeating pattern of axis (str), start
          (float), stop (float).

          In general:

          .. code-block:: python

              axis1, start1, stop1, axis2, start2, stop2, ..., axisN, startN,
              stopN

          Axis is any extra axis name supported by the current diffractometer
          geometry and mode.
      num: int
          Number of points.
      pseudos: dict
          Dictionary of pseudo axes positions to be held constant during the
          scan.
      reals: dict
          Dictionary of real axes positions to be held constant during the
          scan.
      extras: dict
          Dictionary of extra axes positions to be held constant during the
          scan.
      fail_on_exception: bool
          When True (deafult: False), scan will raise any exceptions. When
          False, all exceptions during the scan will be printed to console.
      md: dict
          Dictionary of user-supplied metadata.



   .. py:method:: _format_value_for_repr(x, digits)
      :staticmethod:


      Format numeric values for display without changing them.

      - Floats: fixed-point with `digits` decimals, trailing zeros
        removed but at least one decimal retained (e.g. 4 -> 4.0).
      - Other types: fall back to built-in repr.



   .. py:method:: _make_wrapped_namedtuple_class(orig_cls, digits)
      :classmethod:


      Return a lightweight subclass of ``orig_cls`` with concise repr.

      Avoid re-wrapping when the same digit count is already applied.
      Supports control of displayed numerical precision in position tuples.



   .. py:property:: auxiliary_axis_names
      :type: list[str]


      Names of all auxiliary positioners, in order of appearance.

      Auxiliary axes are all components using (subclasses of
      'ophyd.PositionerBase') that are not pseudos or reals.

      Example::

          >>> fourc.auxiliary_axis_names
          ['h2', 'k2', 'l2']


   .. py:property:: pseudo_axis_names

      Names of all the pseudo axes, in order of appearance.

      Example::

          >>> fourc.pseudo_axis_names
          ['h', 'k', 'l']


   .. py:property:: real_axis_names

      Names of all the real axes, in order of appearance.

      Example::

          >>> fourc.real_axis_names
          ['omega', 'chi, 'phi', 'tth']


   .. py:property:: samples

      Dictionary of samples.


   .. py:property:: sample

      Current sample object.


   .. py:method:: wh(digits=4, full=False)

      Concise report of the current diffractometer positions.



.. py:function:: creator(*, prefix: str = '', name: str = '', solver: str = 'hkl_soleil', geometry: str = 'E4CV', beam_kwargs: dict[str, object] = {}, solver_kwargs: dict[str, object] = {}, pseudos: list = [], reals: list[str] | dict[str, str | None] = {}, aliases: dict[str, list[str]] = {}, motor_labels: list = ['motors'], labels: list = ['diffractometer'], class_name: str = 'Hklpy2Diffractometer', class_bases: list = [DiffractometerBase], forward_solution_function: Optional[str] = None, **kwargs)

   Factory function to create a diffractometer instance.

   EXAMPLES:

   Four-circle diffractometer, vertical orientation, Eulerian rotations,
   canonical real axis names, EPICS motor PVs::

       e4cv = creator(name="e4cv",
           solver="hkl_soleil", geometry="E4CV",
           reals=dict(omega="IOC:m1", chi="IOC:m2", phi="IOC:m3", tth="IOC:m4"),
       )

   Four-circle diffractometer, vertical orientation, Eulerian rotations,
   custom real axis names, simulated positioners::

       sim4c = creator(name="sim4c",
           solver="hkl_soleil", geometry="E4CV",
           reals=dict(uno=None, dos=None, tres=None, cuatro=None),
       )

   (Simplest case to get a simulator.)
   Four-circle diffractometer, vertical orientation, Eulerian rotations,
   canonical real axis names, simulated positioners (all default settings)::

       sim4c = creator(name="sim4c")

   Kappa six-circle diffractometer, simulated motors::

       simk6c = creator(name="simk6c",
           solver="hkl_soleil", geometry="K6C"
       )

   PARAMETERS

   prefix : str
       EPICS PV prefix (default: empty string)
   name : str
       Name of the ophyd diffractometer object to be created. (default: '""')
   solver : str
       Name of the backend solver providing the geometry. (default: '"hkl_soleil"')
   geometry : str
       Name of the diffractometer geometry. (default: '"E4CV"')
   beam_kwargs : dict[str, object]
       Additional configuration for the incident beam.
       (default: '{"class": "hklpy2.incident.WavelengthXray"}')
   solver_kwargs : dict[str, object]
       Additional configuration for the solver. (default: '{"engine": "hkl"}')
   pseudos : list
       Specification of the names of any pseudo axis positioners
       in addition to the ones provided by the solver.

       (default: '[]' which means no additional pseudo axes)
   reals : dict
       Specification of the real axis motors.  Dictionary keys are the motor
       names, values are the EPICS motor PV for that axis.  If the PV is
       'None', use a simulated positioner.

       The dictionary can be empty or must have at least the canonical number of
       real axes.  The order of the axes is important.  The names provided will
       be mapped to the canonical order defined by the solver.  Components will
       be created for any extra *reals*.

       (default: '{}' which means use the canonical names for the real axes and
       use simulated positioners)
   aliases: dict[str, list[str]]
       Aliases of diffractometer axes for solver's pseudos and reals.

       (default: '{}' which means use the first diffractometer axes from each to match the solver.)
   motor_labels : list
       Ophyd object labels for each real positioner. (default: '["motors"]')
   labels : list
       Ophyd object labels for the diffractometer object. (default: '["diffractometer"]')
   class_name : str
       Name to use for the diffractometer class.
       (default: '"Hklpy2Diffractometer"')
   class_bases : list
       List of base classes to use for the diffractometer class.
       (default: '[DiffractometerBase]')
   forward_solution_function : str
       Name of function to pick one solution from list of possibilities.
       Used by :meth:`~hklpy2.diffract.DiffractometerBase.forward`.
       (default: :func:`~hklpy2.misc.pick_first_solution`)

       Will be assigned to :attr:`hklpy2.diffract.DiffractometerBase._forward_solution`.
   kwargs : any
       Additional keyword arguments will be added when constructing
       the new diffractometer object.


.. py:function:: diffractometer_class_factory(*, solver: str = 'hkl_soleil', geometry: str = 'E4CV', beam_kwargs: dict[str, object] = {}, solver_kwargs: dict[str, object] = {'engine': 'hkl'}, pseudos: list = [], reals: list[str] | dict[str, str | None] = {}, motor_labels: list = ['motors'], class_name: str = 'Hklpy2Diffractometer', class_bases: list = [DiffractometerBase], aliases: dict[str, list[str]] = {}, forward_solution_function: Optional[str] = None) -> DiffractometerBase

   Build a custom class for this diffractometer geometry.

   PARAMETERS

   solver : str
       Name of the backend solver providing the geometry. (default: '"hkl_soleil"')
   geometry : str
       Name of the diffractometer geometry. (default: '"E4CV"')
   beam_kwargs : dict[str, object]
       Additional configuration for the incident beam.
       (default: '{"class": "hklpy2.incident.WavelengthXray"}')
   solver_kwargs : str
       Additional configuration for the solver. (default: '{"engine": "hkl"}')
   pseudos : list
       Specification of the names of any pseudo axis positioners
       in addition to the ones provided by the solver.

       (default: '[]' which means no additional pseudo axes)
   reals : dict or list or None
       Specification of the real axis motors.

       None or empty means use the canonical names for the real axes and use
       simulated positioners (``ophyd.SoftPositioner``) for each.  Otherwise,
       you must specify at least the number of real axes expected by the solver
       geometry.

       list:
           Specify the names of the real axis motors.  The names will be
           matched, in order, to the names used by the solver.
           The default class will be ``ophyd.SoftPositioner``.
       dict:
           Keys: The names of the real axis motors.  The names will be
               matched, in order, to the names used by the solver.
           Values:
               * A string representing the EPICS motor PV.
               * ``None`` for a simulated positioner using ``ophyd.SoftPositioner``.
               * A dictionary with additional specifications for the motor constructor.
                 Use this case for any case where either a string or ``None``
                 are insufficient to specify all necessary parameters.
   motor_labels : list
       Ophyd object labels for each real positioner. (default: '["motors"]')
   class_name : str
       Name to use for the diffractometer class.
       (default: '"Hklpy2Diffractometer"')
   class_bases : list
       List of base classes to use for the diffractometer class.
       (default: '[DiffractometerBase]')
   aliases: dict[str, list[str]]
       Aliases of diffractometer axes for solver's pseudos and reals.

       (default: '{}' which means use the first diffractometer axes from each to match the solver.)
   forward_solution_function : str
       Name of function to pick one solution from list of possibilities.
       Used by :meth:`~hklpy2.diffract.DiffractometerBase.forward`.
       (default: :func:`~hklpy2.misc.pick_first_solution`)

       Will be assigned to :attr:`hklpy2.diffract.DiffractometerBase._forward_solution`.


.. py:data:: A_KEV
   :value: 12.398419843856837


   X-ray voltage wavelength product (:math:`h \nu`), per NIST standard.

.. py:data:: SOLVER_ENTRYPOINT_GROUP
   :value: 'hklpy2.solver'


   Name by which |hklpy2| backend |solver| classes are grouped.

.. py:class:: ConfigurationRunWrapper(*devices, knowns=None)

   Write configuration of supported device(s) to a bluesky run.

   EXAMPLE::

       crw = ConfigurationRunWrapper(sim4c2)
       RE.preprocessors.append(crw.wrapper)
       RE(bp.rel_scan([noisy], m1, -1.2, 1.2, 11))

   Disable the preprocessor::

       crw.enable = False  # 'True' to enable

   Remove the last preprocessor::

       RE.preprocessors.pop()

   Add another diffractometer::

       crw.devices.append(e4cv)

   .. autosummary::

       ~device_names
       ~devices
       ~enable
       ~known_bases
       ~start_key
       ~validate
       ~wrapper


   .. py:attribute:: devices
      :value: []


      List of devices to be reported.


   .. py:attribute:: known_bases
      :value: []


      Known device base classes.

      Any device (base class) that reports its configuration dictionary in
      the `.read_configuration()` method can be added to this tuple.


   .. py:attribute:: start_key
      :value: 'diffractometers'


      Top-level key in run's metadata dictionary.


   .. py:property:: enable
      :type: bool


      Is it permitted to write device configuration?


   .. py:property:: device_names
      :type: list[str]


      Return list of configured device names.


   .. py:method:: validate(devices) -> None

      Verify all are recognized objects.



   .. py:method:: wrapper(plan)

      Bluesky plan wrapper (preprocessor).

      Writes device(s) configuration to start document metadata.

      Example::

          crw = ConfigurationRunWrapper(e4cv)
          RE.preprocessors.append(crw.wrapper)



.. py:exception:: SolverError

   Bases: :py:obj:`Hklpy2Error`


   Custom exceptions from a |solver|.


.. py:function:: get_solver(solver_name)

   Load a Solver class from a named entry point.

   ::

       import hklpy2
       SolverClass = hklpy2.get_solver("hkl_soleil")
       libhkl_solver = SolverClass()


.. py:function:: solver_factory(solver_name: str, geometry: str, **kwargs)

   Create a |solver| object with geometry and axes.


.. py:function:: solvers()

   Dictionary of available Solver classes, mapped by entry point name.

   ::

       import hklpy2
       print(hklpy2.solvers())


