hklpy2.ops
==========

.. py:module:: hklpy2.ops

.. autoapi-nested-parse::

   Operate the diffractometer using a |solver| library and geometry.

   Intermediate layer between DiffractometerBase Device and backend |solver|
   library.

   .. autosummary::

       ~Core



Classes
-------

.. autoapisummary::

   hklpy2.ops.Core


Module Contents
---------------

.. py:class:: Core(diffractometer, default_sample: bool = True)

   Core operations of a diffractometer, coordinating with sample & |solver|.

   .. rubric:: Parameters

   diffractometer (DiffractometerBase):
       The diffractometer parent.
   default_sample (bool):
       If 'True' (default), create a 'sample' with 1 angstrom cubic lattice.

   .. rubric:: Python Methods

   .. autosummary::

       ~_asdict
       ~_fromdict
       ~_validate_pseudos
       ~add_reflection
       ~add_sample
       ~assign_axes
       ~calc_UB
       ~forward
       ~geometries
       ~inverse
       ~local_pseudo_axes
       ~local_real_axes
       ~refine_lattice
       ~remove_sample
       ~request_solver_update
       ~reset_constraints
       ~reset_samples
       ~set_solver
       ~standardize_pseudos
       ~standardize_reals
       ~update_solver

   .. rubric:: Python Properties

   .. autosummary::

       ~all_extras
       ~extras
       ~geometry
       ~mode
       ~modes
       ~sample
       ~solver
       ~solver_extra_axis_names
       ~solver_name
       ~solver_pseudo_axis_names
       ~solver_real_axis_names
       ~solver_signature
       ~solver_summary


   .. py:attribute:: axes_xref


   .. py:attribute:: diffractometer


   .. py:attribute:: _extras


   .. py:attribute:: _mode
      :value: None



   .. py:attribute:: _sample_name
      :value: None



   .. py:attribute:: _samples


   .. py:attribute:: _solver
      :value: None



   .. py:attribute:: constraints
      :value: None



   .. py:attribute:: configuration
      :value: None



   .. py:method:: _asdict()

      Describe the diffractometer as a dictionary.



   .. py:method:: _axes_names_s2d(axis_dict: dict[str, float]) -> dict[str, float]

      Convert keys of axis dictionary from solver to diffractometer.



   .. py:method:: _axes_names_d2s(axis_dict: dict[str, float]) -> dict[str, float]

      Convert keys of axis dictionary from diffractometer to solver.



   .. py:method:: _fromdict(config)

      Redefine diffractometer from a (configuration) dictionary.



   .. py:method:: _validate_extras(values: dict[str, Number], expected: dict[str, Number]) -> dict[str, Number]

      Validate that the supplied extras are acceptable.



   .. py:method:: _validate_pseudos(pseudos) -> bool

      Validate that the supplied pseudos are acceptable.



   .. py:method:: add_reflection(pseudos: hklpy2.misc.AnyAxesType, reals: Union[hklpy2.misc.AnyAxesType, None] = None, wavelength=None, name=None, replace: bool = False) -> hklpy2.blocks.reflection.Reflection

      Add a new reflection.

      .. rubric:: Parameters

      * ``pseudos`` (various): pseudo-space axes and values.
      * ``reals`` (various): dictionary of real-space axes and values.
      * ``wavelength`` (float): Wavelength of incident radiation.
      * ``name`` (str): Reference name for this reflection.
        If ``None``, a random name will be assigned.
      * ``replace`` (bool): If ``True``, replace existing reflection of
        this name.  (default: ``False``)



   .. py:method:: add_sample(name: str, a: float, b: float = None, c: float = None, alpha: float = 90.0, beta: float = None, gamma: float = None, digits: int = 4, replace: bool = False) -> hklpy2.blocks.sample.Sample

      Add a new sample.



   .. py:property:: all_extras
      :type: list[str]


      Sorted dictionary of |solver| extra parameters in any mode.


   .. py:method:: assign_axes(pseudos: list[str], reals: list[str]) -> None

      Designate attributes for use by the PseudoPositioner class.

      Result is re-definition of 'self.axes_xref'.



   .. py:property:: axes_xref_reversed

      Map axis names from solver to diffractometer.


   .. py:method:: calc_UB(r1: Union[hklpy2.blocks.reflection.Reflection, str], r2: Union[hklpy2.blocks.reflection.Reflection, str]) -> List[List[Number]]

      Calculate and return the UB (orientation) matrix with two reflections.

      The method of Busing & Levy, Acta Cryst 22 (1967) 457.



   .. py:property:: extras
      :type: list[str]


      Ordered dictionary of |solver| extra parameters in current mode.


   .. py:method:: forward(pseudos: hklpy2.misc.AnyAxesType, wavelength: float = None) -> list

      Compute [{names:reals}] from {names: pseudos} (hkl -> angles).



   .. py:method:: geometries() -> list[str]

      Return all available |solver| geometries.



   .. py:property:: geometry
      :type: str


      Return the |solver| geometry.


   .. py:method:: inverse(reals: Union[hklpy2.misc.AnyAxesType, None], wavelength: float = None) -> hklpy2.misc.AxesDict

      Compute (pseudos) from {names: reals} (angles -> hkl).



   .. py:property:: local_pseudo_axes
      :type: list


      List of the diffractometer pseudo axes expected by the solver.

      This becomes useful when additional pseudo axes are named
      as ophyd Components in the diffractometer.


   .. py:property:: local_real_axes
      :type: list


      List of the diffractometer real axes expected by the solver.

      This becomes useful when additional real axes are named
      as ophyd Components in the diffractometer.


   .. py:property:: mode
      :type: str


      Return the current computation mode.


   .. py:property:: modes
      :type: list[str]


      Return the list of available |solver| modes.


   .. py:method:: refine_lattice(reflections: list = None) -> hklpy2.blocks.lattice.Lattice

      Return the sample lattice computed from 3 or more reflections.

      Do not change the sample lattice.  Let the user decide that.



   .. py:method:: remove_sample(name)

      Remove the named sample.  No error if name is not known.



   .. py:method:: request_solver_update(flag: bool = True) -> None

      Set (or clear) signal to trigger a solver update.

      Needs to be a method (not a property) so it can be called from a
      wavelength method.



   .. py:method:: reset_constraints()

      Restore diffractometer constraints to default settings.



   .. py:method:: reset_samples()

      Restore diffractometer samples to default settings.



   .. py:property:: sample
      :type: hklpy2.blocks.sample.Sample


      Current Sample (Python object).


   .. py:property:: samples
      :type: dict


      Sample dictionary.


   .. py:property:: solver
      :type: hklpy2.backends.base.SolverBase


      Backend |solver| object.


   .. py:property:: solver_extra_axis_names
      :type: list[str]


      Ordered list of any |solver| extra axis names in current mode.


   .. py:property:: solver_name
      :type: str


      Name of |solver|.


   .. py:property:: solver_pseudo_axis_names
      :type: list[str]


      Ordered list of |solver| pseudo axis names.


   .. py:property:: solver_real_axis_names
      :type: list[str]


      Ordered list of |solver| real axis names.


   .. py:property:: solver_signature
      :type: str


      Return 'repr(self.solver)' for use as ophyd.AttributeSignal.


   .. py:property:: solver_summary
      :type: str


      Return table of solver's geometry (modes, axes)..


   .. py:method:: set_solver(name: str, geometry: str, **kwargs: dict) -> hklpy2.backends.base.SolverBase

      Create an instance of the backend |solver| library and geometry.

      Parameters

      solver str:
          Name of the |solver| library.
      geometry str:
          Name of the |solver| geometry.
      kwargs dict:
          Any keyword arguments needed by the |solver|.



   .. py:method:: standardize_pseudos(pseudos: hklpy2.misc.AnyAxesType) -> hklpy2.misc.AxesDict

      Convert user-supplied pseudos into dictionary in solver's order.

      User could provide pseudos in several forms:

      * dict: {"h": 0, "k": 1, "l": -1}
      * namedtuple: (h=0.0, k=1.0, l=-1.0)
      * ordered list: [0, 1, -1]  (for h, k, l)
      * ordered tuple: (0, 1, -1)  (for h, k, l)



   .. py:method:: standardize_reals(reals: Union[hklpy2.misc.AnyAxesType, None]) -> hklpy2.misc.AxesDict

      Convert user-supplied reals into dictionary in solver's order.

      User could provide reals in several forms:

      * None: current positions
      * dict: {"omega": 120, "chi": 35.3, "phi": 45, "tth": -120}
      * namedtuple: (omega=120, chi=35.3, phi=45, tth=-120)
      * ordered list: [120, 35.3, 45, -120]  (for omega, chi, phi, tth)
      * ordered tuple: (120, 35.3, 45, -120)  (for omega, chi, phi, tth)



   .. py:method:: update_solver(wavelength: Optional[float] = None) -> None

      Update solver data if needed.



