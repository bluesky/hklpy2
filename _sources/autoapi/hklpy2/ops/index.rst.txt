hklpy2.ops
==========

.. py:module:: hklpy2.ops

.. autoapi-nested-parse::

   Operate the diffractometer using a |solver| library and geometry.

   Intermediate layer between DiffractometerBase Device and backend |solver|
   library.

   .. autosummary::

       ~Operations



Classes
-------

.. autoapisummary::

   hklpy2.ops.Operations


Module Contents
---------------

.. py:class:: Operations(diffractometer, default_sample: bool = True)

   Operate the diffractometer using a |solver|.

   .. rubric:: Parameters

   ``diffractometer`` (DiffractometerBase):
       The diffractometer parent.
   ``default_sample`` (bool):
       If 'True' (default), create a 'sample' with 1 angstrom cubic lattice.

   .. rubric:: Python Methods

   .. autosummary::

       ~_asdict
       ~_fromdict
       ~_validate_pseudos
       ~add_reflection
       ~add_sample
       ~assign_axes
       ~auto_assign_axes
       ~calc_UB
       ~forward
       ~inverse
       ~local_pseudo_axes
       ~local_real_axes
       ~refine_lattice
       ~remove_sample
       ~reset_constraints
       ~reset_samples
       ~set_solver
       ~standardize_pseudos
       ~standardize_reals

   .. rubric:: Python Properties

   .. autosummary::

       ~geometry
       ~sample
       ~solver


   .. py:attribute:: axes_xref


   .. py:attribute:: diffractometer


   .. py:attribute:: _sample_name
      :value: None



   .. py:attribute:: _samples


   .. py:attribute:: _solver
      :value: None



   .. py:attribute:: constraints
      :value: None



   .. py:attribute:: configuration
      :value: None



   .. py:method:: _asdict()

      Describe the diffractometer as a dictionary.



   .. py:method:: _fromdict(config)

      Redefine diffractometer from a (configuration) dictionary.



   .. py:method:: _validate_pseudos(pseudos) -> bool

      Validate that the supplied pseudos are acceptable.



   .. py:method:: add_reflection(pseudos: hklpy2.misc.AnyAxesType, reals: Union[hklpy2.misc.AnyAxesType, None] = None, wavelength=None, name=None, replace: bool = False) -> hklpy2.blocks.reflection.Reflection

      Add a new reflection.

      .. rubric:: Parameters

      * ``pseudos`` (various): pseudo-space axes and values.
      * ``reals`` (various): dictionary of real-space axes and values.
      * ``wavelength`` (float): Wavelength of incident radiation.
      * ``name`` (str): Reference name for this reflection.
        If ``None``, a random name will be assigned.
      * ``replace`` (bool): If ``True``, replace existing reflection of
        this name.  (default: ``False``)



   .. py:method:: add_sample(name: str, a: float, b: float = None, c: float = None, alpha: float = 90.0, beta: float = None, gamma: float = None, digits: int = 4, replace: bool = False) -> hklpy2.blocks.sample.Sample

      Add a new sample.



   .. py:method:: assign_axes(pseudos: list[str], reals: list[str]) -> None

      Designate attributes for use by the PseudoPositioner class.

      Result is re-definition of 'self.axes_xref'.



   .. py:method:: _axes_names_s2d(axis_dict: dict[str, float]) -> dict[str, float]

      Convert keys of axis dictionary from solver to diffractometer.



   .. py:method:: _axes_names_d2s(axis_dict: dict[str, float]) -> dict[str, float]

      Convert keys of axis dictionary from diffractometer to solver.



   .. py:property:: axes_xref_reversed

      Map axis names from solver to diffractometer.


   .. py:method:: auto_assign_axes()

      Automatically assign diffractometer axes to this solver.

      .. note:: The ordered lists of axes names **could change**
         when the |solver|, or any of its settings, such as `mode`,
         are changed.  The lists are defined by the |solver| library.

         .. seealso:: Each |solver| provides ordered lists of the
            names it expects:

            * :attr:`~hklpy2.backends.base.SolverBase.extra_axis_names`
            * :attr:`~hklpy2.backends.base.SolverBase.pseudo_axis_names`
            * :attr:`~hklpy2.backends.base.SolverBase.real_axis_names`



   .. py:method:: calc_UB(r1: Union[hklpy2.blocks.reflection.Reflection, str], r2: Union[hklpy2.blocks.reflection.Reflection, str]) -> List[List[Number]]

      Calculate and return the UB (orientation) matrix with two reflections.

      The method of Busing & Levy, Acta Cryst 22 (1967) 457.



   .. py:method:: forward(pseudos: hklpy2.misc.AnyAxesType, wavelength: float = None) -> list

      Compute [{names:reals}] from {names: pseudos} (hkl -> angles).



   .. py:method:: forward_solutions_table(reflections, full=False, digits=5)

      Return table of computed solutions for each supplied (hkl) reflection.

      The solutions are calculated using the current UB matrix & constraints.

      :param reflections: Each reflection is a tuple of 3 numbers,
                          (h, k, l) of the reflection.
      :type reflections: list of (h, k, l) reflections
      :param full: If ``True``, show all solutions.  If ``False``,
                   only show the default solution.
      :type full: bool
      :param digits: Number of digits to roundoff each position
                     value.  Default is 5.
      :type digits: int



   .. py:method:: inverse(reals: Union[hklpy2.misc.AnyAxesType, None], wavelength: float = None) -> hklpy2.misc.AxesDict

      Compute (pseudos) from {names: reals} (angles -> hkl).



   .. py:property:: local_pseudo_axes
      :type: list


      List of the diffractometer pseudo axes expected by the solver.

      This becomes useful when additional pseudo axes are named
      as ophyd Components in the diffractometer.


   .. py:property:: local_real_axes
      :type: list


      List of the diffractometer real axes expected by the solver.

      This becomes useful when additional real axes are named
      as ophyd Components in the diffractometer.


   .. py:method:: refine_lattice(reflections: list = None) -> hklpy2.blocks.lattice.Lattice

      Return the sample lattice computed from 3 or more reflections.

      Do not change the sample lattice.  Let the user decide that.



   .. py:method:: remove_sample(name)

      Remove the named sample.  No error if name is not known.



   .. py:method:: reset_constraints()

      Restore diffractometer constraints to default settings.



   .. py:method:: reset_samples()

      Restore diffractometer samples to default settings.



   .. py:method:: set_solver(name: str, geometry: str, **kwargs: dict) -> hklpy2.backends.base.SolverBase

      Create an instance of the backend |solver| library and geometry.

      .. rubric:: Parameters

      * ``solver`` (str): Name of the |solver| library.
      * ``geometry`` (str): Name of the |solver| geometry.
      * ``kwargs`` (dict): Any keyword arguments needed by the |solver|.



   .. py:method:: standardize_pseudos(pseudos: hklpy2.misc.AnyAxesType) -> hklpy2.misc.AxesDict

      Convert user-supplied pseudos into dictionary in solver's order.

      User could provide pseudos in several forms:

      * dict: {"h": 0, "k": 1, "l": -1}
      * namedtuple: (h=0.0, k=1.0, l=-1.0)
      * ordered list: [0, 1, -1]  (for h, k, l)
      * ordered tuple: (0, 1, -1)  (for h, k, l)



   .. py:method:: standardize_reals(reals: Union[hklpy2.misc.AnyAxesType, None]) -> hklpy2.misc.AxesDict

      Convert user-supplied reals into dictionary in solver's order.

      User could provide reals in several forms:

      * None: current positions
      * dict: {"omega": 120, "chi": 35.3, "phi": 45, "tth": -120}
      * namedtuple: (omega=120, chi=35.3, phi=45, tth=-120)
      * ordered list: [120, 35.3, 45, -120]  (for omega, chi, phi, tth)
      * ordered tuple: (120, 35.3, 45, -120)  (for omega, chi, phi, tth)



   .. py:property:: geometry
      :type: str


      Backend |solver| geometry name.


   .. py:property:: sample
      :type: hklpy2.blocks.sample.Sample


      Current Sample (Python object).


   .. py:property:: samples
      :type: dict


      Sample dictionary.


   .. py:property:: solver
      :type: hklpy2.backends.base.SolverBase


      Backend |solver| object.


